# docker-compose.yml

services:
  # The database service. It's the heart of our application.
  db:
    # We'll use the official MySQL 8.0 image. It's a solid choice.
    image: mysql:8.0
    container_name: mysql_db
    environment:
      # These are super important for local development.
      # Remember to change these for a production environment!
      MYSQL_ROOT_PASSWORD: root_password
      MYSQL_DATABASE: ecommerce_db
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    ports:
      # We're exposing the standard MySQL port so we can connect to it from our computer
      # with a database tool if we want to.
      - "3306:3306"
    volumes:
      # This is a named volume to make sure our database data doesn't get lost
      # every time we stop the container.
      - db_data:/var/lib/mysql
    healthcheck:
      # This is a critical check! We're making sure the database is actually ready
      # before the API service tries to connect to it. It prevents a lot of headaches.
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10
    networks:
      - ecommerce_network

  # This is our backend API service, built with FastAPI.
  product-catalog-service:
    # Docker Compose knows to find the Dockerfile in the product-catalog-service folder.
    build: ./product-catalog-service
    container_name: product_catalog_app
    environment:
      # We tell the API how to connect to the database.
      # The hostname 'db' works automatically because that's the service name here.
      DATABASE_URL: "mysql+mysqlconnector://user:password@db:3306/ecommerce_db"
    # NEW: A more reliable health check using Python.
    healthcheck:
      # This command uses Python to try to connect to the port, which is guaranteed to be available.
      test: ["CMD-SHELL", "python -c \"import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(1); s.connect(('localhost', 8000)); s.close()\""]
      interval: 5s
      timeout: 5s
      retries: 5
    depends_on:
      # We're telling Docker to wait for the database to be healthy before starting this service.
      db:
        condition: service_healthy
    networks:
      - ecommerce_network
      
  # This container's only job is to build our React app. It's part of a smart two-step process.
  frontend-builder:
    build:
      context: ./frontend
      # We're telling it to stop after the 'build' stage in our multi-stage Dockerfile.
      target: build
    container_name: ecommerce_frontend_builder
    # We use a volume to save the built app, which we'll use in the next service.
    volumes:
      - frontend_build_data:/app/build

  # This is our Nginx service. It's a super fast web server that will serve our app.
  nginx:
    # We're using the official Nginx image directly, which is clean and efficient.
    image: nginx:alpine
    container_name: ecommerce_nginx
    ports:
      # Map our computer's port 80 to the container's port 80.
      # This lets us access the app at http://localhost.
      - "80:80"
    volumes:
      # We grab the built app from the volume we created earlier.
      - frontend_build_data:/usr/share/nginx/html:ro
      # CRITICAL FIX: Mounting the custom nginx.conf directly to the main config file.
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      # We have to wait for the app to be built before Nginx can serve it.
      frontend-builder:
        condition: service_completed_successfully
      # We now wait for the API service to be HEALTHY before Nginx starts!
      product-catalog-service:
        condition: service_healthy
    networks:
      - ecommerce_network

# --- A few global settings for Docker Compose ---

networks:
  # This creates a network so all our containers can find and talk to each other by name.
  ecommerce_network:
    driver: bridge

volumes:
  # The named volumes we're using to persist our database data and pass files between services.
  db_data:
  frontend_build_data:
